package fakeBrains;

import java.util.*;
import java.awt.geom.Point2D;
import java.awt.geom.Point2D.Double;
import java.awt.geom.RectangularShape;

import problem.*;

public class PRMGraph {
	
	// The list of nodes
	List<Node> nodes;
	// The List of Points
	List<Point2D.Double> points;
	
	// The List of Obstacles
	List<Obstacle> obstacles;
	
	// le initial range
	double range;
	
	// Really dodgy constructor
	public PRMGraph(){
		nodes = new ArrayList<Node>();
		points = new ArrayList<Point2D.Double>();
	}
	
	/* Populates a space the size of mapSize with points.
	 * Converts them to nodes and connects nodes within range if they
	 * there can be a legitimate connection.
	 */
	public PRMGraph(List<Obstacle> obstacles, double range, int pointCount, Point2D.Double mapSize){
		// Init them thingos
		nodes = new ArrayList<Node>();
		points = new ArrayList<Point2D.Double>();
		this.range = range;
		this.obstacles = obstacles;
		Node.setNodeIndex(0);
		
		// Make the points
		makePoints(mapSize, pointCount);
		this.nodes = convertPoints2Nodes(points);
		connectNodes();
	}
	
	/* Alternate constructor for when you don't want to change mapsize */
	public PRMGraph(List<Obstacle> obstacles, double range, int pointCount){
		this(obstacles, range, pointCount, new Point2D.Double(1.0,1.0));
	}
		
	/* Connects the nodes if the connections are valid and they are within a certain range */
	private void connectNodes(){
		for(int i = 0; i < nodes.size(); i++)
			for(int k = 0; k < nodes.size(); k++){
				// For each node, check if there's a valid connection to another node nearby
				Node a = new Node(nodes.get(i)); Node b = new Node(nodes.get(k)); // don't make pointers
				// if we're not the same and the distance is good
				if(!a.equals(b) && b.getPos().distance(a.getPos()) <= range){
					// make a temp edge
					Edge edge = new Edge(a, b);
					// if the edge isn't blocked add the edge to the nodes
					if(!edge.isBlocked(obstacles)){
						nodes.get(i).addEdge(nodes.get(k));
					}
				}
			}
	}
	
	private void connectNode(Node n){
		for(int k = 0; k < nodes.size(); k++) {
		// For each node, check if there's a valid connection to another node nearby
			Node a = new Node(n);  // don't make pointers
			Node b = new Node(nodes.get(k));
			
			// if we're not the same and the distance is good
			if(!a.equals(b) && b.getPos().distance(a.getPos()) <= range){
				// make a temp edge
				Edge edge = new Edge(a, b);
				// if the edge isn't blocked add the edge to the nodes
				if(!edge.isBlocked(obstacles)){
					n.addEdge(nodes.get(k));
				}
			}
		}
	}
	
	
	/* Makes an amount of points and randomly distributes them through the area mapSize.
	 * If a point lands in an obstacle it is shifted until it isn't by using obstaclePoint
	 */
	private void makePoints(Point2D.Double mapSize, int num){
		// Start 
		Random tempRand = new Random(); boolean badSpot;
		Random rand = new Random(tempRand.nextInt());
		for(int i=0; i < num; i++){
			badSpot = false;
			double ran1 = rand.nextDouble();
			//System.out.println("Using " + ran1 + " as a seed");
			double ran2 = rand.nextDouble();
			Point2D.Double temp = new Point2D.Double((mapSize.x * ran1), (mapSize.y * ran2));
			for(int k = 0; k < obstacles.size(); k++){
				if(obstacles.get(k).getRect().contains(temp.x, temp.y)) badSpot = true;
			}
			if(badSpot){
				points.add(obstaclePoint(temp));			
			}
			if(!badSpot) points.add(temp);
		}
		//System.out.println(points.size());
	}
	
	/** Takes a list of points, makes them into nodes and connects 
	 * the nodes to all their possible neighbours.
	 * Returns a Hashmap of the Nodes with their Points as their keys
	 */
	public Map<Point2D.Double, Node> addPoints(List<Point2D.Double> p) {
		// Make map to return
		Map<Point2D.Double, Node> newPoints = new HashMap<Point2D.Double, Node>();
		// convert the points to nodes
		List<Node> newNodes = convertPoints2Nodes(p);
		
		// Connect the Nodes
		for(int i = 0; i < newNodes.size(); i++){
			connectNode(newNodes.get(i));
		}
		
		// Make the map to return
		for(int i = 0; i < p.size(); i++){
			newPoints.put(p.get(i), newNodes.get(i));
		}
		return newPoints;
	}
	
	/* Moves a point until it is no longer in an obstacle */
	private Point2D.Double obstaclePoint(Point2D.Double p){
		Random r = new Random(); boolean badSpot = false;
		//System.out.println("Got: " + r.nextGaussian());
		Point2D.Double newP = new Point2D.Double(p.x + range*r.nextGaussian(), p.y + range*r.nextGaussian());
		for(int k = 0; k < obstacles.size(); k++){
			if(obstacles.get(k).getRect().contains(newP.x, newP.y)) badSpot = true;
		}
		if(badSpot) return obstaclePoint(newP);
		else return newP;
	}
	
	/* Makes a new node at every point in p */
	private List<Node> convertPoints2Nodes(List<Point2D.Double> p){
		List<Node> n = new ArrayList<Node>();
		for(int i = 0; i < p.size(); i++){
			n.add(new Node(p.get(i).x, p.get(i).y));
		}
		return n;
	}
	
	
	public List<Point2D> getPoints(){
		return new ArrayList<Point2D>(points);
	}
	
	public List<Node> getNodes(){
		return new ArrayList<Node>(nodes);
	}
	
}
